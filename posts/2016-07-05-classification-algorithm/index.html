<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.3.433">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Jan Vanhove">
<meta name="dcterms.date" content="2016-07-05">

<title>Jan Vanhove :: Blog - Classifying second-language learners as native- or non-nativelike: Don’t neglect classification error rates</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 20,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg navbar-dark ">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Jan Vanhove :: Blog</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html" rel="" target="">
 <span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../archive.html" rel="" target="">
 <span class="menu-text">Blog archive</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resources.html" rel="" target="">
 <span class="menu-text">Teaching resources</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../publications.html" rel="" target="">
 <span class="menu-text">Publications</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="../../archive.xml" rel="" target=""><i class="bi bi-rss" role="img">
</i> 
 <span class="menu-text"></span></a>
  </li>  
</ul>
            <div class="quarto-navbar-tools">
</div>
          </div> <!-- /navcollapse -->
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#background-classifying-l2-learners-as-native--or-non-nativelike" id="toc-background-classifying-l2-learners-as-native--or-non-nativelike" class="nav-link active" data-scroll-target="#background-classifying-l2-learners-as-native--or-non-nativelike">Background: classifying L2 learners as native- or non-nativelike</a></li>
  <li><a href="#the-problem-misclassifications" id="toc-the-problem-misclassifications" class="nav-link" data-scroll-target="#the-problem-misclassifications">The problem: Misclassifications</a></li>
  <li><a href="#illustration" id="toc-illustration" class="nav-link" data-scroll-target="#illustration">Illustration</a></li>
  <li><a href="#estimating-error-rates-using-classification-algorithms" id="toc-estimating-error-rates-using-classification-algorithms" class="nav-link" data-scroll-target="#estimating-error-rates-using-classification-algorithms">Estimating error rates using classification algorithms</a></li>
  <li><a href="#conclusions" id="toc-conclusions" class="nav-link" data-scroll-target="#conclusions">Conclusions</a></li>
  <li><a href="#software-versions" id="toc-software-versions" class="nav-link" data-scroll-target="#software-versions">Software versions</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Classifying second-language learners as native- or non-nativelike: Don’t neglect classification error rates</h1>
  <div class="quarto-categories">
    <div class="quarto-category">R</div>
    <div class="quarto-category">machine learning</div>
    <div class="quarto-category">random forests</div>
  </div>
  </div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Jan Vanhove </p>
          </div>
  </div>
    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 5, 2016</p>
    </div>
  </div>
  
    
  </div>
  

</header>

<p>I’d promised to write another installment on drawing <a href="../2016-06-21-drawing-a-boxplot">graphs</a>, but instead I’m going to write about something that I had to exclude, for reasons of space, from a recently published <a href="https://folia.unifr.ch/unifr/documents/304945">book chapter</a> on age effects in second language (L2) acquisition: <strong>classifying</strong> observations (e.g., L2 learners) and <strong>estimating error rates</strong>.</p>
<p>I’m going to illustrate the usefulness of classification algorithms for addressing some problems in L2 acquisition research, but my broader aim is to show that there’s more to statistics than running significance tests and to encourage you to explore—even if superficially—what else is out there.</p>
<section id="background-classifying-l2-learners-as-native--or-non-nativelike" class="level2">
<h2 class="anchored" data-anchor-id="background-classifying-l2-learners-as-native--or-non-nativelike">Background: classifying L2 learners as native- or non-nativelike</h2>
<p>In the field of second language acquisition, there are a couple of theories that predict that L2 learners who begin learning the L2 after a certain age will never be ‘native-like’ in the L2. The ‘certain age’ differs between studies, and what the prediction boils down to in some versions is that <em>no</em> L2 learner will ever be fully ‘native-like’ in the L2.</p>
<p>I, for one, don’t think that ‘nativelikeness’ is a useful scientific construct, but that doesn’t matter for this post: Some researchers obviously do consider it useful, and for them the question is how they can test their prediction.</p>
<p>Researchers interested in nativelikeness usually administer a battery of linguistic tasks to a sample of L2 learners as well as to a ‘control’ sample of L1 speakers. On the basis of the L1 speakers’ results, they then define a <strong>nativelikeness criterion</strong>—an interval that is considered typical of L1 speakers’ performance. Common intervals are (a) the L1 speakers’ mean ± two standard deviations or (b) the range of the L1 speakers’ results. L2 speakers whose results fall outside this interval are considered non-nativelike, and the goal of the study is often to establish from which age of L2 acquisition onwards no nativelike L2 speakers can be found.</p>
</section>
<section id="the-problem-misclassifications" class="level2">
<h2 class="anchored" data-anchor-id="the-problem-misclassifications">The problem: Misclassifications</h2>
<p>The procedure I’ve just sketched is pretty common but it’s <strong>statistically naïve</strong>. One problem with it is that it may misclassify non-nativelike speakers as nativelike. I think most researchers are aware of this problem, as it’s sometimes implied that fewer L2 learners would’ve qualified as nativelike if only more and more reliable data were available. This may well be true. But the other side of the coin is rarely considered: not all L1 speakers may pass the nativelikeness criterion either!</p>
<p>To my knowledge, no paper in L2 acquisition provides an <strong>error-rate estimate</strong>, i.e., a quantitative appraisal of how well the nativelikeness criterion would distinguish between L2 and L1 speakers <em>other than those used for defining the criterion</em>. Nonetheless, I think this is precisely what is needed if we are to sensibly interpret such studies. Let me illustrate.</p>
</section>
<section id="illustration" class="level2">
<h2 class="anchored" data-anchor-id="illustration">Illustration</h2>
<p><a href="http://dx.doi.org/10.1111/j.1467-9922.2009.00507.x">Abrahamsson and Hyltenstam</a> subjected 41 advanced Spanish-speaking learners of L2 Swedish as well as 15 native speakers of Swedish to a battery of linguistic tasks. From these tasks, 14 variables were extracted; the details don’t matter much here, but you can look them up in the paper (see Table 6 on page 280). Abrahamsson and Hyltenstam defined the minimum criterion of nativelikeness as the lowest native-speaker result on each measure, but I’m going to define it as the range of native-speaker results (i.e., between lowest and highest; it doesn’t really matter much).</p>
<p>The original raw data aren’t available, but I’ve simulated some placeholder data to illustrate my point.</p>
<p>(For the 15 native speakers, I simulated 14 variables from normal distributions with the same mean as in Abrahamsson &amp; Hyltenstam’s Table 6; the standard deviation was estimated by taking the range and dividing it by 4. For the 41 non-native speakers, I simulated the same 14 variables but with generally lower means and larger standard deviations. None of the variables were systematically correlated. This simulation obviously represent a huge simplification; life would be easier if people <a href="../2015-12-14-perks-data-sharing">put their data online</a>.)</p>
<p>Using these simulated data, we can compute the range of the native-speaker results. Don’t be intimidated by the R code, the comments say what it accomplishes, which is really all you need to know.</p>
<p><strong>Update (2023-08-08):</strong> I’ve reran this code using newer software versions. I now also rely on the <code>tidyverse</code> suite of packages instead of on the individual packages that later went on to form the <code>tidyverse</code> suite.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Read in data</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>dat <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"http://homeweb.unifr.ch/VanhoveJ/Pub/Data/nativelikeness.csv"</span>,</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>                <span class="at">stringsAsFactors =</span> <span class="cn">TRUE</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(dat)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   56 obs. of  15 variables:
 $ Pred1 : int  18 15 17 13 22 21 15 20 18 20 ...
 $ Pred2 : int  12 17 14 16 16 12 19 13 22 14 ...
 $ Pred3 : int  18 11 16 15 20 14 20 18 18 14 ...
 $ Pred4 : int  -5 11 0 -3 2 -9 2 7 16 6 ...
 $ Pred5 : int  19 11 21 8 20 24 13 9 14 19 ...
 $ Pred6 : int  29 22 21 24 19 24 28 27 19 21 ...
 $ Pred7 : int  -10 -8 -5 -9 -8 -6 -8 -7 -4 -2 ...
 $ Pred8 : int  16 15 16 17 16 17 17 16 16 15 ...
 $ Pred9 : int  73 74 70 64 70 72 64 76 63 63 ...
 $ Pred10: int  71 70 74 67 73 65 73 66 72 66 ...
 $ Pred11: int  7852 6977 7246 7768 8106 8457 7680 8156 7672 8417 ...
 $ Pred12: int  38 34 35 33 36 35 36 37 33 36 ...
 $ Pred13: int  45 41 45 42 46 40 36 38 39 48 ...
 $ Pred14: int  41 40 36 36 40 41 41 44 38 36 ...
 $ Class : Factor w/ 2 levels "L1 speaker","L2 speaker": 1 1 1 1 1 1 1 1 1 1 ...</code></pre>
</div>
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load packages</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Retain L1 speakers</span></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a>dat.L1 <span class="ot">&lt;-</span> dat <span class="sc">|&gt;</span></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Class <span class="sc">==</span> <span class="st">"L1 speaker"</span>)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute minimum and maximum for numeric data</span></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a>min.L1 <span class="ot">&lt;-</span> dat.L1 <span class="sc">|&gt;</span></span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise_if</span>(is.numeric, min)</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a>max.L1 <span class="ot">&lt;-</span> dat.L1 <span class="sc">|&gt;</span></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">summarise_if</span>(is.numeric, max)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>We can then take a look at the L2 speakers’ results and filter out the L2 speakers whose results aren’t all within the native speakers’ range:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Retain L2 speakers</span></span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>dat.L2 <span class="ot">&lt;-</span> dat <span class="sc">|&gt;</span> <span class="fu">filter</span>(Class <span class="sc">==</span> <span class="st">"L2 speaker"</span>)</span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Retain only L2 speakers whose results lie within L1 speakers' range</span></span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a>dat.nativelikeL2 <span class="ot">&lt;-</span> dat.L2 <span class="sc">|&gt;</span></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred1 <span class="sc">&gt;=</span> min.L1[[<span class="dv">1</span>]], Pred1 <span class="sc">&lt;=</span> max.L1[[<span class="dv">1</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred2 <span class="sc">&gt;=</span> min.L1[[<span class="dv">2</span>]], Pred2 <span class="sc">&lt;=</span> max.L1[[<span class="dv">2</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred3 <span class="sc">&gt;=</span> min.L1[[<span class="dv">3</span>]], Pred3 <span class="sc">&lt;=</span> max.L1[[<span class="dv">3</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred4 <span class="sc">&gt;=</span> min.L1[[<span class="dv">4</span>]], Pred4 <span class="sc">&lt;=</span> max.L1[[<span class="dv">4</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred5 <span class="sc">&gt;=</span> min.L1[[<span class="dv">5</span>]], Pred5 <span class="sc">&lt;=</span> max.L1[[<span class="dv">5</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred6 <span class="sc">&gt;=</span> min.L1[[<span class="dv">6</span>]], Pred6 <span class="sc">&lt;=</span> max.L1[[<span class="dv">6</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred7 <span class="sc">&gt;=</span> min.L1[[<span class="dv">7</span>]], Pred7 <span class="sc">&lt;=</span> max.L1[[<span class="dv">7</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-13"><a href="#cb4-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred8 <span class="sc">&gt;=</span> min.L1[[<span class="dv">8</span>]], Pred8 <span class="sc">&lt;=</span> max.L1[[<span class="dv">8</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-14"><a href="#cb4-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred9 <span class="sc">&gt;=</span> min.L1[[<span class="dv">9</span>]], Pred9 <span class="sc">&lt;=</span> max.L1[[<span class="dv">9</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-15"><a href="#cb4-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred10 <span class="sc">&gt;=</span> min.L1[[<span class="dv">10</span>]], Pred10 <span class="sc">&lt;=</span> max.L1[[<span class="dv">10</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-16"><a href="#cb4-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred11 <span class="sc">&gt;=</span> min.L1[[<span class="dv">11</span>]], Pred11 <span class="sc">&lt;=</span> max.L1[[<span class="dv">11</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-17"><a href="#cb4-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred12 <span class="sc">&gt;=</span> min.L1[[<span class="dv">12</span>]], Pred12 <span class="sc">&lt;=</span> max.L1[[<span class="dv">12</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-18"><a href="#cb4-18" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred13 <span class="sc">&gt;=</span> min.L1[[<span class="dv">13</span>]], Pred13 <span class="sc">&lt;=</span> max.L1[[<span class="dv">13</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb4-19"><a href="#cb4-19" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred14 <span class="sc">&gt;=</span> min.L1[[<span class="dv">14</span>]], Pred14 <span class="sc">&lt;=</span> max.L1[[<span class="dv">14</span>]])</span>
<span id="cb4-20"><a href="#cb4-20" aria-hidden="true" tabindex="-1"></a>dat.nativelikeL2 <span class="sc">|&gt;</span> <span class="fu">nrow</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0</code></pre>
</div>
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># = empty dataset</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Sure enough, none of the L2 learners classify as nativelike. (With more realistic data, a handful probably would have, cf.&nbsp;Abrahamsson &amp; Hyltenstam’s results.)</p>
<p>By contrast, and quite obviously, all fifteen native speakers are classified as nativelike:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>dat.L1 <span class="sc">|&gt;</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred1 <span class="sc">&gt;=</span> min.L1[[<span class="dv">1</span>]], Pred1 <span class="sc">&lt;=</span> max.L1[[<span class="dv">1</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred2 <span class="sc">&gt;=</span> min.L1[[<span class="dv">2</span>]], Pred2 <span class="sc">&lt;=</span> max.L1[[<span class="dv">2</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred3 <span class="sc">&gt;=</span> min.L1[[<span class="dv">3</span>]], Pred3 <span class="sc">&lt;=</span> max.L1[[<span class="dv">3</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred4 <span class="sc">&gt;=</span> min.L1[[<span class="dv">4</span>]], Pred4 <span class="sc">&lt;=</span> max.L1[[<span class="dv">4</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred5 <span class="sc">&gt;=</span> min.L1[[<span class="dv">5</span>]], Pred5 <span class="sc">&lt;=</span> max.L1[[<span class="dv">5</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred6 <span class="sc">&gt;=</span> min.L1[[<span class="dv">6</span>]], Pred6 <span class="sc">&lt;=</span> max.L1[[<span class="dv">6</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred7 <span class="sc">&gt;=</span> min.L1[[<span class="dv">7</span>]], Pred7 <span class="sc">&lt;=</span> max.L1[[<span class="dv">7</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred8 <span class="sc">&gt;=</span> min.L1[[<span class="dv">8</span>]], Pred8 <span class="sc">&lt;=</span> max.L1[[<span class="dv">8</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred9 <span class="sc">&gt;=</span> min.L1[[<span class="dv">9</span>]], Pred9 <span class="sc">&lt;=</span> max.L1[[<span class="dv">9</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred10 <span class="sc">&gt;=</span> min.L1[[<span class="dv">10</span>]], Pred10 <span class="sc">&lt;=</span> max.L1[[<span class="dv">10</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred11 <span class="sc">&gt;=</span> min.L1[[<span class="dv">11</span>]], Pred11 <span class="sc">&lt;=</span> max.L1[[<span class="dv">11</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred12 <span class="sc">&gt;=</span> min.L1[[<span class="dv">12</span>]], Pred12 <span class="sc">&lt;=</span> max.L1[[<span class="dv">12</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-14"><a href="#cb7-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred13 <span class="sc">&gt;=</span> min.L1[[<span class="dv">13</span>]], Pred13 <span class="sc">&lt;=</span> max.L1[[<span class="dv">13</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-15"><a href="#cb7-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred14 <span class="sc">&gt;=</span> min.L1[[<span class="dv">14</span>]], Pred14 <span class="sc">&lt;=</span> max.L1[[<span class="dv">14</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb7-16"><a href="#cb7-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">nrow</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 15</code></pre>
</div>
</div>
<p>This comes as no surprise: the nativelikeness criterion was based on these speakers’ scores, so of course they should pass it with flying colours.</p>
<p>But what happens when we test a new sample of native speakers <em>using the old nativelikeness criterion</em>? I simulated data for another 10,000 native speakers using the same procedure I used to create the first 15 native speakers’ data.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Read in data for *new* L1 speakers</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>new.L1 <span class="ot">&lt;-</span> <span class="fu">read.csv</span>(<span class="st">"http://homeweb.unifr.ch/VanhoveJ/Pub/Data/new_nativelikeness.csv"</span>,</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>                   <span class="at">stringsAsFactors =</span> <span class="cn">TRUE</span>)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a><span class="fu">str</span>(new.L1)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>'data.frame':   10000 obs. of  14 variables:
 $ Pred1 : int  14 15 21 17 17 18 18 17 23 18 ...
 $ Pred2 : int  14 18 16 12 16 15 15 10 15 15 ...
 $ Pred3 : int  17 18 14 16 23 13 20 21 22 21 ...
 $ Pred4 : int  1 21 -17 3 -2 1 7 0 -1 16 ...
 $ Pred5 : int  23 15 14 12 11 15 6 14 17 20 ...
 $ Pred6 : int  24 24 26 26 26 29 17 29 24 25 ...
 $ Pred7 : int  -10 -6 -8 -6 -10 -3 -6 -8 -6 -9 ...
 $ Pred8 : int  16 13 15 14 17 17 15 14 18 16 ...
 $ Pred9 : int  64 77 69 64 66 73 67 70 71 66 ...
 $ Pred10: int  67 73 70 63 74 74 75 62 66 75 ...
 $ Pred11: int  7159 8098 8344 7113 7142 7808 7388 8062 8124 7864 ...
 $ Pred12: int  38 32 28 32 38 32 39 38 35 31 ...
 $ Pred13: int  41 42 44 49 40 37 44 47 43 52 ...
 $ Pred14: int  36 38 38 40 36 45 41 40 43 39 ...</code></pre>
</div>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Retain only participants whose results lie within *original* L1 speakers' range</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>new.L1 <span class="sc">|&gt;</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred1 <span class="sc">&gt;=</span> min.L1[[<span class="dv">1</span>]], Pred1 <span class="sc">&lt;=</span> max.L1[[<span class="dv">1</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred2 <span class="sc">&gt;=</span> min.L1[[<span class="dv">2</span>]], Pred2 <span class="sc">&lt;=</span> max.L1[[<span class="dv">2</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred3 <span class="sc">&gt;=</span> min.L1[[<span class="dv">3</span>]], Pred3 <span class="sc">&lt;=</span> max.L1[[<span class="dv">3</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred4 <span class="sc">&gt;=</span> min.L1[[<span class="dv">4</span>]], Pred4 <span class="sc">&lt;=</span> max.L1[[<span class="dv">4</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred5 <span class="sc">&gt;=</span> min.L1[[<span class="dv">5</span>]], Pred5 <span class="sc">&lt;=</span> max.L1[[<span class="dv">5</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-8"><a href="#cb11-8" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred6 <span class="sc">&gt;=</span> min.L1[[<span class="dv">6</span>]], Pred6 <span class="sc">&lt;=</span> max.L1[[<span class="dv">6</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-9"><a href="#cb11-9" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred7 <span class="sc">&gt;=</span> min.L1[[<span class="dv">7</span>]], Pred7 <span class="sc">&lt;=</span> max.L1[[<span class="dv">7</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-10"><a href="#cb11-10" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred8 <span class="sc">&gt;=</span> min.L1[[<span class="dv">8</span>]], Pred8 <span class="sc">&lt;=</span> max.L1[[<span class="dv">8</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-11"><a href="#cb11-11" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred9 <span class="sc">&gt;=</span> min.L1[[<span class="dv">9</span>]], Pred9 <span class="sc">&lt;=</span> max.L1[[<span class="dv">9</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-12"><a href="#cb11-12" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred10 <span class="sc">&gt;=</span> min.L1[[<span class="dv">10</span>]], Pred10 <span class="sc">&lt;=</span> max.L1[[<span class="dv">10</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-13"><a href="#cb11-13" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred11 <span class="sc">&gt;=</span> min.L1[[<span class="dv">11</span>]], Pred11 <span class="sc">&lt;=</span> max.L1[[<span class="dv">11</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-14"><a href="#cb11-14" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred12 <span class="sc">&gt;=</span> min.L1[[<span class="dv">12</span>]], Pred12 <span class="sc">&lt;=</span> max.L1[[<span class="dv">12</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-15"><a href="#cb11-15" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred13 <span class="sc">&gt;=</span> min.L1[[<span class="dv">13</span>]], Pred13 <span class="sc">&lt;=</span> max.L1[[<span class="dv">13</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-16"><a href="#cb11-16" aria-hidden="true" tabindex="-1"></a>  <span class="fu">filter</span>(Pred14 <span class="sc">&gt;=</span> min.L1[[<span class="dv">14</span>]], Pred14 <span class="sc">&lt;=</span> max.L1[[<span class="dv">14</span>]]) <span class="sc">|&gt;</span></span>
<span id="cb11-17"><a href="#cb11-17" aria-hidden="true" tabindex="-1"></a>  <span class="fu">nrow</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1048</code></pre>
</div>
</div>
<p>Only 1048 of the 10,000 new native speakers pass the nativelikeness criterion! And these 10,000 new native speakers were sampled from the <em>exact same</em> population as the fifteen speakers used to establish the nativelikeness criterion—factors that would matter in real life such as social status, age, region, linguistic background, and what not don’t matter here; these would only make matters worse (see this <a href="http://dare.uva.nl/document/2/148989">paper</a> on the selection of native-speaker controls by Sible Andringa).</p>
<p>Clearly, <strong>the finding that none of the L2 speakers are classified as nativelike carries considerably less weight now that we know that most L1 speakers wouldn’t have, either</strong>. Such information about the error rate associated with the nativelikeness criterion is therefore crucial to properly interpret studies relying on such a criterion. In practice, the bias against being classified as nativelike may not be huge as in this simulated example, but without an error-rate estimate (or access to the raw data), we’ve no way of knowing.</p>
</section>
<section id="estimating-error-rates-using-classification-algorithms" class="level2">
<h2 class="anchored" data-anchor-id="estimating-error-rates-using-classification-algorithms">Estimating error rates using classification algorithms</h2>
<p>If researchers want to classify L2 learners as nativelike or non-nativelike and sensibly interpret their results, I suggest they stop defining nativelikeness criteria as intervals based on native speakers’ scores. Instead, they can turn to tools developed in a field specialised in such matters: <strong>machine learning</strong>, or <strong>predictive modelling</strong>. There’s an astounding number of algorithms out there that were developed for taking a set of predictor variables (e.g., task scores) on the one hand and a set of class labels (e.g., <em>L1 speaker</em> vs.&nbsp;<em>L2 speaker</em>) on the other hand, deriving a classification model from these data, and estimating the error rate of the classifications.</p>
<p>I won’t provide a detailed introduction—Kuhn &amp; Johnson’s <a href="http://appliedpredictivemodeling.com/"><em>Applied Predictive Modeling</em></a> seems excellent—but I’ll just illustrate one such classification algorithm, <strong>random forests</strong>. In fact, the precise workings of this algorithm, which was developed in 2001 by Leo Breiman, needn’t really concern us here—you can read about them <a href="http://projecteuclid.org/euclid.ss/1009213726">from the horse’s mouth</a>, so to speak, in my <a href="http://homeweb.unifr.ch/VanhoveJ/Pub/papers/Diss/VanhoveJ.pdf#subsection.9.3.2">thesis</a>, or in tutorials by <a href="http://dx.doi.org/10.1017/S0954394512000129">Tagliamonte &amp; Baayen</a> or <a href="http://www.ncbi.nlm.nih.gov/pmc/articles/PMC2927982/">Strobl and colleagues</a>. What’s important is that it often produces <strong>excellent classification models</strong> and that it computes an <strong>error-rate estimate</strong> as a matter of course.</p>
<p>The <code>randomForest</code> function in the <code>randomForest</code> package implements the algorithm. There are a couple of settings that the user can tweak; again these needn’t concern us here—you can read about these in the articles referred to above.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Load the randomForest package;</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="co"># you may need to run 'install.packages("randomForest")' first.</span></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(randomForest)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Random forest have built-in random variability;</span></span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="co"># by setting the random seed, you'll get the same result as me.</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="co"># You can try setting a different seed or not setting one</span></span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a><span class="co"># and see what happens</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a><span class="fu">set.seed</span>(<span class="dv">5-7-2016</span>)</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Use a random forest to predict Class (L1 vs. L2 speaker)</span></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co"># by means of all other variables in the dataset.</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>nativelike.rf <span class="ot">&lt;-</span> <span class="fu">randomForest</span>(Class <span class="sc">~</span> ., <span class="at">data =</span> dat)</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Output, including confusion matrix</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a>nativelike.rf</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
Call:
 randomForest(formula = Class ~ ., data = dat) 
               Type of random forest: classification
                     Number of trees: 500
No. of variables tried at each split: 3

        OOB estimate of  error rate: 16.07%
Confusion matrix:
           L1 speaker L2 speaker class.error
L1 speaker          8          7  0.46666667
L2 speaker          2         39  0.04878049</code></pre>
</div>
</div>
<p>The output shows the estimated classification error that was computed on the basis of the original (simulated) data with 15 L1 and 41 L2 speakers (<code>OBB estimate of error rate</code>): an estimated 16.1% of observations will be misclassified by this algorithm. With more data (more observations, more predictors, more reliable predictors), this estimated error rate may become more accurate.</p>
<p>More interesting for our present purposes is the confusion matrix: The algorithm wrongly classifies two out of 41 L2 speakers as L1 speakers—these could perhaps be considered to have passed an updated ‘nativelikeness criterion’ inasmuch as they ‘fooled’ the algorithm. <strong>But it also misclassifies 7 of the 15 L1 speakers as L2 speakers.</strong> In this case, then, the 5% ‘nativelikeness incidence’ among L2 speakers may be an underestimate, as the algorithm seems to be biased against classifying participants as L1 speakers. This is likely due to the <strong>imbalance</strong> in the data: there are about 3 times more L2 than L1 speakers, so the algorithm naturally defaults to L2 speakers. (Take-home message if you want to conduct a study on nativelikeness: include more native speakers.)</p>
<p>The same random forest can also be applied to the 10,000 new L1 speakers, which gives a better estimate of how much the odds are stacked against classifying a participant as an L1 speaker:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>new.predictions <span class="ot">&lt;-</span> <span class="fu">predict</span>(nativelike.rf, <span class="at">newdata =</span> new.L1)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(new.predictions)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>L1 speaker L2 speaker 
      7745       2255 </code></pre>
</div>
</div>
<p>While the random forest doesn’t classify all L1 speakers in the original control sample as L1 speakers (as the naïve nativelikeness procedure did), it performs much better on new L1 data, classifying 77% of new L1 speakers as L1 speakers. Evidently, in a real study, we wouldn’t have a sample of 10,000 participants on the side to check the estimated classification error rate.</p>
</section>
<section id="conclusions" class="level2">
<h2 class="anchored" data-anchor-id="conclusions">Conclusions</h2>
<ol type="a">
<li><p>By using common definitions of nativelikeness criteria, L2 acquisition studies are likely to stack the odds against findings of nativelikeness and yield generally uninterpretable results.</p></li>
<li><p>Random forests and other classification algorithms will yield considerably <strong>better classifications</strong> than ad-hoc criteria, but they may be far from perfect. Their <strong>imperfection</strong>, unlike that of ad-hoc criteria, can be quantified, however, which is crucial for interpreting the results.</p></li>
<li><p>You’re unlikely to learn about such algorithms in an introductory course to statistics, but it’s useful to <strong>simply know that they exist</strong>. This is how you build up your statistical toolbox: when you know that these tools exist and have a vague sense of what they’re for, you can brush up on them when you need them. There’s a world beyond <em>t</em>-tests, ANOVA and Pearson’s <em>r</em>.</p></li>
</ol>
</section>
<section id="software-versions" class="level2">
<h2 class="anchored" data-anchor-id="software-versions">Software versions</h2>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>devtools<span class="sc">::</span><span class="fu">session_info</span>()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>─ Session info ───────────────────────────────────────────────────────────────
 setting  value
 version  R version 4.3.1 (2023-06-16)
 os       Ubuntu 22.04.2 LTS
 system   x86_64, linux-gnu
 ui       X11
 language en_US
 collate  en_US.UTF-8
 ctype    en_US.UTF-8
 tz       Europe/Zurich
 date     2023-08-08
 pandoc   3.1.1 @ /usr/lib/rstudio/resources/app/bin/quarto/bin/tools/ (via rmarkdown)

─ Packages ───────────────────────────────────────────────────────────────────
 package      * version date (UTC) lib source
 cachem         1.0.6   2021-08-19 [2] CRAN (R 4.2.0)
 callr          3.7.3   2022-11-02 [1] CRAN (R 4.3.1)
 cli            3.6.1   2023-03-23 [1] CRAN (R 4.3.0)
 colorspace     2.1-0   2023-01-23 [1] CRAN (R 4.3.0)
 crayon         1.5.2   2022-09-29 [1] CRAN (R 4.3.1)
 devtools       2.4.5   2022-10-11 [1] CRAN (R 4.3.1)
 digest         0.6.29  2021-12-01 [2] CRAN (R 4.2.0)
 dplyr        * 1.1.2   2023-04-20 [1] CRAN (R 4.3.0)
 ellipsis       0.3.2   2021-04-29 [2] CRAN (R 4.2.0)
 evaluate       0.15    2022-02-18 [2] CRAN (R 4.2.0)
 fansi          1.0.4   2023-01-22 [1] CRAN (R 4.3.1)
 fastmap        1.1.0   2021-01-25 [2] CRAN (R 4.2.0)
 forcats      * 1.0.0   2023-01-29 [1] CRAN (R 4.3.0)
 fs             1.5.2   2021-12-08 [2] CRAN (R 4.2.0)
 generics       0.1.3   2022-07-05 [1] CRAN (R 4.3.0)
 ggplot2      * 3.4.2   2023-04-03 [1] CRAN (R 4.3.0)
 glue           1.6.2   2022-02-24 [2] CRAN (R 4.2.0)
 gtable         0.3.3   2023-03-21 [1] CRAN (R 4.3.0)
 hms            1.1.3   2023-03-21 [1] CRAN (R 4.3.0)
 htmltools      0.5.5   2023-03-23 [1] CRAN (R 4.3.0)
 htmlwidgets    1.6.2   2023-03-17 [1] CRAN (R 4.3.1)
 httpuv         1.6.11  2023-05-11 [1] CRAN (R 4.3.1)
 jsonlite       1.8.7   2023-06-29 [1] CRAN (R 4.3.1)
 knitr          1.39    2022-04-26 [2] CRAN (R 4.2.0)
 later          1.3.1   2023-05-02 [1] CRAN (R 4.3.1)
 lifecycle      1.0.3   2022-10-07 [1] CRAN (R 4.3.0)
 lubridate    * 1.9.2   2023-02-10 [1] CRAN (R 4.3.0)
 magrittr       2.0.3   2022-03-30 [1] CRAN (R 4.3.0)
 memoise        2.0.1   2021-11-26 [2] CRAN (R 4.2.0)
 mime           0.10    2021-02-13 [2] CRAN (R 4.0.2)
 miniUI         0.1.1.1 2018-05-18 [1] CRAN (R 4.3.1)
 munsell        0.5.0   2018-06-12 [1] CRAN (R 4.3.0)
 pillar         1.9.0   2023-03-22 [1] CRAN (R 4.3.0)
 pkgbuild       1.4.2   2023-06-26 [1] CRAN (R 4.3.1)
 pkgconfig      2.0.3   2019-09-22 [2] CRAN (R 4.2.0)
 pkgload        1.3.2.1 2023-07-08 [1] CRAN (R 4.3.1)
 prettyunits    1.1.1   2020-01-24 [2] CRAN (R 4.2.0)
 processx       3.8.2   2023-06-30 [1] CRAN (R 4.3.1)
 profvis        0.3.8   2023-05-02 [1] CRAN (R 4.3.1)
 promises       1.2.0.1 2021-02-11 [1] CRAN (R 4.3.1)
 ps             1.7.5   2023-04-18 [1] CRAN (R 4.3.1)
 purrr        * 1.0.1   2023-01-10 [1] CRAN (R 4.3.0)
 R6             2.5.1   2021-08-19 [2] CRAN (R 4.2.0)
 randomForest * 4.7-1.1 2022-05-23 [1] CRAN (R 4.3.1)
 Rcpp           1.0.11  2023-07-06 [1] CRAN (R 4.3.1)
 readr        * 2.1.4   2023-02-10 [1] CRAN (R 4.3.0)
 remotes        2.4.2   2021-11-30 [2] CRAN (R 4.2.0)
 rlang          1.1.1   2023-04-28 [1] CRAN (R 4.3.0)
 rmarkdown      2.21    2023-03-26 [1] CRAN (R 4.3.0)
 rstudioapi     0.14    2022-08-22 [1] CRAN (R 4.3.0)
 scales         1.2.1   2022-08-20 [1] CRAN (R 4.3.0)
 sessioninfo    1.2.2   2021-12-06 [2] CRAN (R 4.2.0)
 shiny          1.7.4.1 2023-07-06 [1] CRAN (R 4.3.1)
 stringi        1.7.12  2023-01-11 [1] CRAN (R 4.3.1)
 stringr      * 1.5.0   2022-12-02 [1] CRAN (R 4.3.0)
 tibble       * 3.2.1   2023-03-20 [1] CRAN (R 4.3.0)
 tidyr        * 1.3.0   2023-01-24 [1] CRAN (R 4.3.0)
 tidyselect     1.2.0   2022-10-10 [1] CRAN (R 4.3.0)
 tidyverse    * 2.0.0   2023-02-22 [1] CRAN (R 4.3.1)
 timechange     0.2.0   2023-01-11 [1] CRAN (R 4.3.0)
 tzdb           0.4.0   2023-05-12 [1] CRAN (R 4.3.0)
 urlchecker     1.0.1   2021-11-30 [1] CRAN (R 4.3.1)
 usethis        2.2.2   2023-07-06 [1] CRAN (R 4.3.1)
 utf8           1.2.3   2023-01-31 [1] CRAN (R 4.3.1)
 vctrs          0.6.3   2023-06-14 [1] CRAN (R 4.3.0)
 withr          2.5.0   2022-03-03 [2] CRAN (R 4.2.0)
 xfun           0.39    2023-04-20 [1] CRAN (R 4.3.0)
 xtable         1.8-4   2019-04-21 [1] CRAN (R 4.3.1)
 yaml           2.3.5   2022-02-21 [2] CRAN (R 4.2.0)

 [1] /home/jan/R/x86_64-pc-linux-gnu-library/4.3
 [2] /usr/local/lib/R/site-library
 [3] /usr/lib/R/site-library
 [4] /usr/lib/R/library

──────────────────────────────────────────────────────────────────────────────</code></pre>
</div>
</div>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn) {
    const config = {
      allowHTML: true,
      content: contentFn,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start'
    };
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->



</body></html>